# 第十三章 测试问题

## 真实的实现

在谷歌，对真实的实现的偏爱是随着时间的推移而发展起来的，因为我们看到过度使用mocking框架有一种倾向，即用重复的代码污染测试，与真实实现不同步，使重构变得困难。我们将在本章后面更详细地讨论这个话题。

在测试中更倾向于真实的实现，这被称为经典测试。还有一种测试风格被称为mockist测试，在这种测试中，倾向于使用mocking框架而不是真实实现。尽管软体行业的一些人在进行mockist测试（包括第一个mocking框架的创造者），但在Google，我们发现这种测试方式很难扩展。它要求工程师在设计被测系统时遵循严格的准则，而谷歌大多数工程师的默认行为是以一种更适合经典测试风格的方式来编写代码。

### 偏爱现实主义而非孤立

对依赖关系使用真实的实现，使被测系统更加真实，因为这些真实实现中的所有代码都将在测试中执行。相反，利用双倍的测试将被测系统与其依赖关系隔离开来，这样测试就不会执行被测系统依赖关系中的代码。

我们更喜欢现实的测试，因为它们能给被测系统正常工作带来更多的信心。如果单元测试过于依赖双重测试，工程师可能需要运行集成测试或手动验证他们的功能是否按预期工作，以获得同样的信心。执行这些额外的任务可能会减慢开发速度甚至可能会让错误漏掉，如果工程师完全跳过这些任务，当这些任务太耗时了，与运行单元测试相比。

用测试替身替换类的所有依赖关系会任意地将被测系统与作者恰好直接放在该类中的实现隔离，并排除恰好在不同类中的实现。然而，一个好的测试应该是独立于实现的--它应该从被测试的API的角度来编写，而不是从实现的结构来编写。

如果真实实现中存在bug，使用真实的实现会导致你的测试失败。这是好的，如果你希望你的测试在这种情况下失败，因为这表明你的代码在生产中无法正常工作。有时，真实实现中的一个bug会导致测试失败，因为使用真实实现的其他测试也可能失败。但如果有好的开发者工具，比如持续集成（CI）系统，通常很容易追踪到导致失败的变化。

#### 案例研究: @DoNotMock

在Google，我们已经看到了足够多的过度依赖mocking框架的测试，这促使我们在Java中创建了@DoNotMock注解，它可以作为ErrorProne静态分析工具的一部分。这个注解是API所有者声明的一种方式，"这个类型不应该被mock，因为存在更好的替代方案"。

如果工程师试图使用mocking框架来创建一个被注解为@DoNotMock的类或接口的实例，如例13-10所示，他们会看到一个错误，指示他们使用更合适的测试策略，如真实的实现或假的实现。这个注解最常用于那些简单到可以按原样使用的价值对象，以及那些有精心设计的假的API。

例子 13-10. @DoNotMock的注释 

```java
@DoNotMock("Use SimpleQuery.create() instead of mocking.")
public abstract class Query {
public abstract String getQueryValue();
}
```

为什么API所有者会关心这个问题呢？简而言之，它严重限制了API所有者随着时间的推移对其实现进行修改的能力。正如我们在本章后面所探讨的，每当mocking框架被用于打桩或交互测试时，它都会重复API所提供的行为。

当API所有者想要改变他们的API时，他们可能会发现它已经在整个Google的代码库中被模拟了几千甚至几万次！这些测试替身很可能表现出违反被模拟类型的API要求的行为--例如，为一个永远不能返回空的方法返回空。如果测试使用的是真正的实现或假的，API所有者可以对他们的实现进行修改，而不需要先修复成千上万的有缺陷的测试。

### 如何决定何时使用真实的实施方案

如果一个真实的实现是快速的、确定的，并且有简单的依赖关系，那么它就是首选。例如，一个真实的实现应该被用于一个价值对象。这方面的例子包括一笔钱、一个日期、一个地理位置，或者一个集合类，如列表或地图。

然而，对于更复杂的代码，使用真实实现往往是不可行的。考虑到要进行权衡，什么时候使用真实实现或测试替身可能没有一个确切的答案，所以你需要考虑以下因素。

#### 执行时间

单元测试最重要的要求之一是它们应该是快速的--你希望能够在开发过程中不断地运行它们，这样你就可以快速得到关于你的代码是否能运行的反馈（你也希望它们在CI系统中运行时能够快速完成）。因此，当真正的实现很慢时，测试替身可以非常有用。

对于一个单元测试来说，多慢才算慢？如果一个真正的实现在每个单独的测试用例的运行时间上增加一毫秒，很少有人会把它归类为慢。但如果它增加了10毫秒，100毫秒，1秒，等等呢？

这里没有确切的答案--它可能取决于工程师是否感觉到生产力的损失，以及有多少测试在使用真实的实现（如果有5个测试用例，每个测试用例多一秒钟可能是合理的，但如果有500个测试用例就不一样了）。对于边界情况，通常更简单的是使用真正的实现，直到它变得太慢，在这一点上，测试可以被更新为使用一个测试替身。

并行测试也可以帮助减少执行时间。在谷歌，我们的测试基础设施使得将测试套件中的测试拆分到多个服务器上执行变得非常简单。这增加了CPU时间的成本，但它可以为开发人员节省大量时间。我们将在第18章中进一步讨论这个问题。

鉴于测试需要构建真正的实现以及所有的依赖关系，使用真正的实现会导致构建时间的增加。使用像Bazel这样的高度可扩展的构建系统会有帮助，因为它可以缓存未改变的构建工件。

